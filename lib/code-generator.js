const { Constants, VariableGenerator, Logger } = require('./core');
const esprima = require('esprima');
const escodegen = require('escodegen');
const JSONSelect = require('JSONSelect');

class CodeGeneratorStrategy {
  generate() {
    throw new Error('Abstract method');
  }
}

class CommonJSCodeGenerator extends CodeGeneratorStrategy {
  constructor(moduleName, moduleCode, commonCode, moduleInclude, lexerCode, version) {
    super();
    this.moduleName = moduleName;
    this.moduleCode = moduleCode;
    this.commonCode = commonCode;
    this.moduleInclude = moduleInclude;
    this.lexerCode = lexerCode;
    this.version = version;
  }

  generate() {
    return `/* parser generated by jison ${this.version} */\n${this.commonCode}\n${this.moduleName.match(/\./) ? this.moduleName : 'var ' + this.moduleName} = ${this.moduleCode};\n${this.moduleInclude}${this.lexerCode}\n` +
           `if (typeof require !== 'undefined' && typeof exports !== 'undefined') {\n` +
           `exports.parser = ${this.moduleName};\n` +
           `exports.Parser = ${this.moduleName}.Parser;\n` +
           `exports.parse = function () { return ${this.moduleName}.parse.apply(${this.moduleName}, arguments); };\n` +
           `exports.main = ${String(this.commonjsMain)};\n` +
           `if (typeof module !== 'undefined' && require.main === module) {\n` +
           `  exports.main(process.argv.slice(1));\n}\n}`;
  }

  commonjsMain(args) {
    if (!args[1]) {
      console.log('Usage: ' + args[0] + ' FILE');
      process.exit(1);
    }
    const source = require('fs').readFileSync(require('path').normalize(args[1]), 'utf8');
    return exports.parser.parse(source);
  }
}

class AMDCodeGenerator extends CodeGeneratorStrategy {
  constructor(moduleCode, commonCode, moduleInclude, lexerCode, version) {
    super();
    this.moduleCode = moduleCode;
    this.commonCode = commonCode;
    this.moduleInclude = moduleInclude;
    this.lexerCode = lexerCode;
    this.version = version;
  }

  generate() {
    return `/* parser generated by jison ${this.version} */\n\ndefine(function(require){\n${this.commonCode}\nvar parser = ${this.moduleCode}\n${this.moduleInclude}${this.lexerCode}\nreturn parser;\n});`;
  }
}

class CodeGenerator {
  constructor(generator, version) {
    this.generator = generator;
    this.version = version;
    this.variableGenerator = new VariableGenerator();
  }

  generate(opt) {
    opt = { ...this.generator.options, ...opt };
    const moduleName = opt.moduleName && /^[A-Za-z_$][A-Za-z0-9_$]*$/.test(opt.moduleName) ? opt.moduleName : 'parser';
    const module = this.generateModuleCode();
    const lexerCode = this.generator.lexer && this.generator.lexer.generateModule ? `\n${this.generator.lexer.generateModule()}\nparser.lexer = lexer;` : '';
    const strategy = opt.moduleType === 'amd' ? new AMDCodeGenerator(module.moduleCode, module.commonCode, this.generator.moduleInclude, lexerCode, this.version) :
                     new CommonJSCodeGenerator(moduleName, module.moduleCode, module.commonCode, this.generator.moduleInclude, lexerCode, this.version);
    return strategy.generate();
  }

  generateModuleCode() {
    let parseFn = String(this.generator.parse);
    if (!this.generator.hasErrorRecovery) {
      parseFn = this.removeErrorRecovery(parseFn);
    }
    if (this.generator.options['token-stack']) {
      parseFn = this.addTokenStack(parseFn);
    }
    const tableCode = this.generateTableCode();
    const commonCode = tableCode.commonCode;
    const moduleCode = `{trace: ${String(this.generator.trace || Logger.trace)},` +
                      `yy: {},` +
                      `symbols_: ${JSON.stringify(this.generator.symbolTable).replace(/"([0-9]+)":/g, "$1:")},` +
                      `terminals_: ${JSON.stringify(this.generator.terminals).replace(/"([0-9]+)":/g, "$1:")},` +
                      `productions_: ${JSON.stringify(this.generator.productions_)},` +
                      `performAction: ${String(this.generator.performAction)},` +
                      `table: ${tableCode.moduleCode},` +
                      `defaultActions: ${JSON.stringify(this.generator.defaultActions).replace(/"([0-9]+)":/g, "$1:")},` +
                      `parseError: ${String(this.generator.parseError || (this.generator.hasErrorRecovery ? this.traceParseError : this.parseError))},` +
                      `parse: ${parseFn}}`;
    return {
      commonCode: `/* parser generated by jison ${this.version} */\n${commonCode}\n(function(){\n${commonCode}\nvar parser = ${moduleCode};\n${this.generator.moduleInclude}${this.generator.lexer && this.generator.lexer.generateModule ? this.generator.lexer.generateModule() + '\nparser.lexer = lexer;' : ''}\nfunction Parser() { this.yy = {}; }\nParser.prototype = parser;\nparser.Parser = Parser;\nreturn new Parser;\n})();`,
      moduleCode
    };
  }

  generateTableCode() {
    let moduleCode = JSON.stringify(this.generator.table).replace(/"([0-9]+)"(?=:)/g, "$1");
    const variables = [this.variableGenerator.createObjectCode()];
    moduleCode = moduleCode.replace(/\{\d+:[^\}]+,\d+:[^\}]+\}/g, object => {
      const keys = {};
      let frequentValue, maxKeyCount = 0;
      const keyValues = [];
      const keyValueMatcher = /(\d+):([^:]+)(?=,\d+:|\})/g;
      while (true) {
        const keyValue = keyValueMatcher.exec(object);
        if (!keyValue) break;
        const [_, key, value] = keyValue;
        keys[value] = keys[value] || [];
        keys[value].push(key);
        if (keys[value].length > maxKeyCount) {
          maxKeyCount = keys[value].length;
          frequentValue = value;
        }
      }
      if (maxKeyCount > 1) {
        for (const value in keys) {
          if (value !== frequentValue) {
            keys[value].forEach(k => keyValues.push(`${k}:${value}`));
          }
        }
        const keyValuesStr = keyValues.length ? `,${keyValues.join(',')}` : '';
        object = `o([${keys[frequentValue].join(',')}],${frequentValue}${keyValuesStr})`;
      }
      return object;
    });
    const lists = {};
    const listMatcher = /\[[0-9,]+\]/g;
    while (true) {
      const list = listMatcher.exec(moduleCode);
      if (!list) break;
      lists[list[0]] = (lists[list[0]] || 0) + 1;
    }
    moduleCode = moduleCode.replace(listMatcher, list => {
      let listId = lists[list];
      if (typeof listId === 'number') {
        if (listId === 1) {
          lists[list] = listId = list;
        } else {
          lists[list] = listId = this.variableGenerator.createVariable();
          variables.push(`${listId}=${list}`);
        }
      }
      return listId;
    });
    return { commonCode: `var ${variables.join(',')};`, moduleCode };
  }

  removeErrorRecovery(fn) {
    try {
      const ast = esprima.parse(fn);
      const labeled = JSONSelect.match(':has(:root > .label > .name:val("_handle_error"))', ast);
      const reduced_code = labeled[0].body.consequent.body[3].consequent.body;
      reduced_code[0] = labeled[0].body.consequent.body[1];
      reduced_code[4].expression.arguments[1].properties.pop();
      labeled[0].body.consequent.body = reduced_code;
      return escodegen.generate(ast).replace(/_handle_error:\s?/, '').replace(/\\\\n/g, '\\n');
    } catch (e) {
      return fn;
    }
  }

  addTokenStack(fn) {
    try {
      const ast = esprima.parse(fn);
      const stackAst = esprima.parse(this.tokenStackLex.toString()).body[0];
      stackAst.id.name = 'lex';
      const labeled = JSONSelect.match(':has(:root > .label > .name:val("_token_stack"))', ast);
      labeled[0].body = stackAst;
      return escodegen.generate(ast).replace(/_token_stack:\s?/, '').replace(/\\\\n/g, '\\n');
    } catch (e) {
      return fn;
    }
  }

  tokenStackLex() {
    let token = tstack.pop() || lexer.lex() || Constants.EOF_TOKEN;
    if (typeof token !== 'number') {
      if (Array.isArray(token)) {
        tstack = token;
        token = tstack.pop();
      }
      token = this.generator.symbolTable[token] || token;
    }
    return token;
  }

  parseError(str, hash) {
    if (hash.recoverable) {
      Logger.trace(str);
    } else {
      const error = new Error(str);
      error.hash = hash;
      throw error;
    }
  }

  traceParseError(err, hash) {
    Logger.trace(err);
  }
}

module.exports = { CodeGenerator, CodeGeneratorStrategy, CommonJSCodeGenerator, AMDCodeGenerator };